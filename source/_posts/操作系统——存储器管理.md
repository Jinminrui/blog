---
title: 操作系统——存储器管理
tags: 操作系统
abbrlink: 22423
date: 2019-01-09 10:28:00
---

## 存储器的层次结构

多级存储器结构
![](http://ww1.sinaimg.cn/large/005ZR24Xgy1g0ry139br9j30h608h75n.jpg)

<!-- more -->

![](http://ww1.sinaimg.cn/large/005ZR24Xgy1g0ry18hw7oj30hf084jru.jpg)

## 程序的装入和链接

在多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事，就是要将程序和数据装入内存。如何将一个用户源程序变为一个可在内存中执行的程序，通常要经过以下几步 :
（1）编译：由编译程序（Compiler）将用户源代码编译成
若干个目标模 块（Object Module）；
（2）链接：由链接程序（Linker）将编译后形成的目标模
块以及它们所需要的库函数，链接在一起，形  
 成一个装入模块（Load Module）；
（3）装入：由装入程序（Loader）将装入模块装入内存。

### 程序的链接

- 静态链接：在装入之前目标模块+库函数链接好,以后不在拆开
- 动态链接
  **装入时动态链接**：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。即在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块。
  便于修改和更新
  便于实现对目标模块的共享
  **运行时动态链接**：运行过程中，需要则链接
  拥有装入时动态链接的优点
  加快程序的装入过程，节省内存空间

### 程序的装入

- 方式：绝对装入 、可重定位装入 、动态运行时装入
- 需要注意的问题：
  （1）装入是从外存——>内存；链接是从目标块——>内存的进程
  （2）程序作业中相对地址或逻辑地址——>进程执行需要内存绝对地址或物理地址。因而在装入时，存在着地址转换，称为重定位。
- 绝对装入：只能将目标模块装入指定的内存位置
- 可重定位的装入： 装入时将逻辑地址转换为物理地址(重定位)，逻辑地址从 0 开始
- 动态运行时装入：模块装入内存后没有立即重定位，仍然是相对地址；只
  有当 cpu 执行到具有相对地址的代码时才去重定位——>动态重定位

## 内存的分配

### 单一连续分配：

- 最简单的一种单用户、单任务的分配方式
- 内存分成系统区和用户区两部分

### 固定分区分配

在单一连续分配的基础上，将用户区划分成若干个固定大小的区，每个区可以放一个作业进程，多个进程并发。系统一启动后就已经分好了分区

- 分区大小划分方法：
  （1）分区大小相等：缺乏灵活性；内存空间浪费
  （2）分区大小不等：

### 动态分区

- 根据作业或进程的需要，动态的分配内存，一开始不分区
- 数据结构：空闲分区表或者空闲分区链  
  空闲分区表：以表结构形式记录每个空闲分区的情况。  
  空闲分区链：以链表形式记录每个空闲分区的情况。
- **首次适应算法**
  从空闲分区表或分区链（按照地址递增次序排列）上开始查找，找到第一个满足要求的分区为止，分配内存，余下的部分然仍留在空闲分区表中。
- **循环首次适应算法**
  在为进程分配内存空间时，不再是每次都从链首开始查找，而是**从上次找到的空闲分区的下一个分区**开始查找，直至找到一个能满足要求的空闲分区，从中找出一块与请求大小相等的内存空间分配给作业。为实现该算法，应设置一起始查寻指针，用于指示下一个起始查寻的空闲分区，并采用循环查找方法，即如果最后一个（链尾）空闲分区的大小仍不能满足，则应**返回到第一个空闲分区**，比较其大小是否满足。找到后，应调整起始查寻指针。
- **最佳适应算法**
  将分配表按照分区容量按照从小到大排列，查找时只需要从表首按顺序查找最合适的。每次为作业分 配内存时，总是找一个**既能满足要求、又是最小**的空闲分区分配给作业。“最佳或最合适的”。
- **最坏适应算法**
  所有的空闲分区按从大到小形成空闲分区链，每次分配总是挑选出分配（链）中**最大的分区**进行分配。优点：使剩下的空闲区不至于太小，产生的碎片几率小；有利于中小作业；
- **快速适应算法**
  将空闲分区根据其容量大小进行分类，对每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，因此，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。
- **可重定位分区分配**
  ![](http://ww1.sinaimg.cn/large/005ZR24Xgy1g0ry1h1yixj311e0no46d.jpg)

### 主存不存的存储管理技术

- 移动技术（主存紧凑）
- 对换技术

## 基本分页存储管理

### 分页的思想

- 把逻辑地址空间（程序）分成若干个大小相等的片－－页面或页、加以编号 0 页、1 页、2 页…….
- 把内存也分成和页面大小相等的若干个物理存储块－－物理块加以编号 0 块、1 块、2 块……
- 为进程分配内存时，将进程的~若干~个页装入多个~不相邻~的块中
- 由于进程的最后一页经常装不满一页，因而形成不可以利用的碎片，称为“页内碎片”

### 页面的大小

- 页面若太小:
  （1）虽然可使内存碎片减小，提高内存利用率
  （2）会使每个进程占用较多的页面，从而导致进程的页表过
  长，占用大量的内存
  （3）还会降低页面换进和换出的效率。
- 若页面太大:
  （1）减少页表的长度，提高页面换进换出的速度
  （2）增加页内碎片
- 因此页面的大小应选择合适，大小应是 2 的幂，通常为 512B-8KB。
  ![](http://ww1.sinaimg.cn/large/005ZR24Xly1g0ry1rco34j311m0q648w.jpg)
- 基本分页存储管理的缺点：
  页表是放在内存中的，因此 Cpu 存取一个数据，需要访问内存 2 次。第一次，访问内存中的页表，找出逻辑地址对应的物理地址；第二次访问内存物理地址处的数据.因此，降低了上计算机的处理速度。
- 为了解决这一问题，引入**快表**
  快表是个具有并行查询能力的特殊高速缓冲寄存器（联想寄存器）
  快表内只存放当前访问的页表项
  很快、远远大于内存的速度、提高了地址变换的速度

## 基本分段存储管理

### 分段的目的

- 推动存储管理从 固定分区－>可变分区->分页存储管理的主要动力是 ：提高内存的利用率
- 引入分段管理的目的：满足程序员编写程序的要求：方便编程、信息共享、信息保护、动态增长、动态链接

### 分页与分段的主要区别

- 段是信息的**逻辑单位**，它是根据用户的需要划分的，因此段对用户是可见的；页是信息的**物理单位**，是为了管理主存的方便而划分的，对用户是透明的。
- 页的大小**固定不变**，由系统决定。段的大小是**不固定**的，它由其完成的功能决定。
- 段是向用户提供的是**二维**地址空间，页式向用户提供的是**一维**地址空间，其页号和页内偏移是机器硬件的功能。
- 由于段是信息的逻辑单位，因此便于存贮保护和信息的共享，页的保护和共享受到限制。

## 段页式存储管理

### 引入段页式存储管理的原因

页式管理可以提高内存利用率、段式管理可以满足用户需要，二者结合可以充分利用页式和段式的优点

### 基本思想

先将用户程序分成若干个段、再把每个段中分成若干个页面，同时内存也分成与页面相同大小的块
![](http://ww1.sinaimg.cn/large/005ZR24Xly1g0ry2180zej313y0tyna8.jpg)
